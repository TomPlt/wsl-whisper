#!/usr/bin/env python3
# Re-exec under venv python if not already running inside the venv
import sys, os as _os
_venv = _os.path.expanduser("~/.local/share/whisper-env")
_venv_py = _os.path.join(_venv, "bin", "python3")
if _os.path.exists(_venv_py) and _os.path.realpath(sys.prefix) != _os.path.realpath(_venv):
    _os.execv(_venv_py, [_venv_py] + sys.argv)

"""Push-to-talk speech-to-text using faster-whisper on GPU.

Run in a terminal. Toggle recording with:
  - Enter key (in-terminal fallback)
  - F12 via companion AHK script (touches/removes /tmp/whisper-ptt-signal)
"""

import argparse
import ctypes
import getpass
import os
import signal
import subprocess
import sys
import tempfile
import threading
import time

# Pre-load cuBLAS from pip nvidia package (glibc caches LD_LIBRARY_PATH at
# startup so setting it from Python is too late; ctypes.cdll works though).
_nvidia_cublas = os.path.join(
    sys.prefix, "lib", f"python{sys.version_info.major}.{sys.version_info.minor}",
    "site-packages", "nvidia", "cublas", "lib", "libcublas.so.12",
)
if os.path.exists(_nvidia_cublas):
    ctypes.cdll.LoadLibrary(_nvidia_cublas)

SIGNAL_FILE = "/tmp/whisper-ptt-signal"
DONE_FILE = f"/mnt/c/Users/{getpass.getuser()}/.whisper-ptt-done"
RECORD_PATH = os.path.join(tempfile.gettempdir(), "whisper-ptt-recording.wav")


def load_model(model_name):
    from faster_whisper import WhisperModel

    print(f"Loading model '{model_name}' onto GPU...", flush=True)
    model = WhisperModel(model_name, device="cuda", compute_type="float16")
    print("Model loaded. Ready.", flush=True)
    return model


def start_recording():
    proc = subprocess.Popen(
        [
            "ffmpeg", "-y",
            "-f", "pulse", "-i", "default",
            "-ac", "1", "-ar", "16000",
            RECORD_PATH,
        ],
        stdin=subprocess.PIPE,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return proc


def stop_recording(proc):
    try:
        proc.stdin.write(b"q")
        proc.stdin.flush()
    except (BrokenPipeError, OSError):
        pass
    try:
        proc.wait(timeout=5)
    except subprocess.TimeoutExpired:
        proc.kill()
        proc.wait()


def transcribe(model, language):
    if not os.path.exists(RECORD_PATH) or os.path.getsize(RECORD_PATH) < 1000:
        print("  (no audio captured)", flush=True)
        return None

    kwargs = {"beam_size": 5}
    if language:
        kwargs["language"] = language

    segments, info = model.transcribe(RECORD_PATH, **kwargs)
    text = " ".join(seg.text.strip() for seg in segments).strip()
    return text


def copy_to_clipboard(text):
    clip = "/mnt/c/WINDOWS/system32/clip.exe"
    try:
        subprocess.run([clip], input=text.encode("utf-8"), check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def watch_signal_file(toggle_event, stop_event):
    """Poll for signal file changes and fire toggle_event."""
    prev_exists = os.path.exists(SIGNAL_FILE)
    while not stop_event.is_set():
        exists = os.path.exists(SIGNAL_FILE)
        if exists != prev_exists:
            toggle_event.set()
            prev_exists = exists
        stop_event.wait(0.05)


def watch_stdin(toggle_event, stop_event):
    """Watch for Enter key presses on stdin."""
    while not stop_event.is_set():
        try:
            line = sys.stdin.readline()
            if line == "":  # EOF
                break
            toggle_event.set()
        except EOFError:
            break


def main():
    parser = argparse.ArgumentParser(description="Push-to-talk whisper transcription")
    parser.add_argument("--model", default="base", help="Whisper model (default: base)")
    parser.add_argument("--language", default=None, help="Language code (default: auto-detect)")
    parser.add_argument("--no-clipboard", action="store_true", help="Don't copy to clipboard")
    args = parser.parse_args()

    model = load_model(args.model)

    # Clean up any stale signal/done files
    for f in (SIGNAL_FILE, DONE_FILE):
        if os.path.exists(f):
            os.remove(f)

    toggle_event = threading.Event()
    stop_event = threading.Event()

    signal_thread = threading.Thread(target=watch_signal_file, args=(toggle_event, stop_event), daemon=True)
    signal_thread.start()

    stdin_thread = threading.Thread(target=watch_stdin, args=(toggle_event, stop_event), daemon=True)
    stdin_thread.start()

    print("\nPress Enter or F12 to toggle recording. Ctrl+C to quit.\n", flush=True)

    recording = False
    ffmpeg_proc = None

    def shutdown(signum=None, frame=None):
        nonlocal recording, ffmpeg_proc
        stop_event.set()
        if recording and ffmpeg_proc:
            stop_recording(ffmpeg_proc)
        if os.path.exists(SIGNAL_FILE):
            os.remove(SIGNAL_FILE)
        if os.path.exists(RECORD_PATH):
            os.remove(RECORD_PATH)
        sys.exit(0)

    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)

    try:
        while True:
            toggle_event.wait()
            toggle_event.clear()

            if not recording:
                recording = True
                ffmpeg_proc = start_recording()
                print("  RECORDING... (press Enter or F12 to stop)", flush=True)
            else:
                recording = False
                print("  Stopping...", flush=True)
                stop_recording(ffmpeg_proc)
                ffmpeg_proc = None

                print("  Transcribing...", flush=True)
                text = transcribe(model, args.language)

                if text:
                    print(f"\n  {text}\n", flush=True)
                    if not args.no_clipboard and copy_to_clipboard(text):
                        print("  [Copied to clipboard]\n", flush=True)
                        # Signal AHK to auto-paste into active window
                        try:
                            with open(DONE_FILE, "w") as f:
                                f.write("done")
                        except OSError:
                            pass
                else:
                    print("  (empty transcription)\n", flush=True)
    except (KeyboardInterrupt, SystemExit):
        shutdown()


if __name__ == "__main__":
    main()
